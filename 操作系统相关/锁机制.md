#### Linux中常用锁

临界区：多个使用者可共同操作的代码。



##### 互斥锁mutex

线程A对某临界区加锁，线程B尝试去访问该临界区时会被挂起，原本执行线程B的核**会切换至其它线程**，

直到线程A对该临界区解锁，线程B才会被唤醒。（线程/上下文切换会有消耗，但不会空转cpu）

###### 递归锁和非递归锁

Mutex可分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。

递归锁：又叫可重入锁(reentrant mutex), 同一个线程可多次获取同一个递归锁，不会产生死锁

非递归锁：又叫不可重入锁，如果一个线程多次获取同一个非递归锁，则会产生死锁

Linux下的pthread_mutex_t锁默认是非递归的，可通过PTHREAD_MUTEX_RECURSIVE属性进行设置。



##### 自旋锁spinlock

线程A对某临界区加锁，线程B尝试去访问该临界区时，原本执行线程B的核**不会做线程切换**（也就是线程B不会被挂起），

cpu一直空转轮询资源是否被解锁释放，直到线程A对该临界区解锁。

（没有线程切换的消耗，但是会空转cpu，如果空转等待时间小于线程切换时间，则可选择自旋锁）



##### 读写锁rwlock

也叫共享互斥锁。可分为读模式和写模式。

读模式：其它线程可已读的方式进入临界区，但是不能已写的方式进入，因此为共享锁；

写模式：其它线程无论以什么方式都无法进入临界区，因此为互斥锁。

使用情景：读远大于写的情况使用rwlock

PS：某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞



##### 条件变量condition variables

用来等待线程，而不是上锁，通常和**互斥锁**一起使用。

**条件变量和互斥锁**的典型使用就是**生产者和消费者模型**。

```c
// 线程A
pthread_mutex_lock(&mutex);
// 如果用if的话，会导致虚假唤醒，解决方式是使用while，继续判断cond
while (cond is False) {
    pthread_cond_wait(&cond, &mutex); // 释放mutex，加wait锁
}
pthread_mutex_unlock(&mutex);

// 线程B
pthread_mutex_lock(&mutex);
// 修改条件
if (cond is True) {
    pthread_cond_signal(&cond, &mutext);  // 唤醒wait锁；虚假唤醒：可能会唤醒多个正在休眠的线程
}
```





**互斥锁和自旋锁选择：**

cpu调度时间大于(空转)等待时间（操作简单，不需要花费太多时间），则选用自旋锁；