#### 一，计算机软硬件基本结构

CPU核心频率提升，导致内存跟不上CPU速度，于是产生了与内存频率一致的系统总线，而CPU采用倍频的方式与系统总线进行通信。

慢速的IO总线无法满足图形设备的巨大需求，为了协调CPU，内存和高速的图形设备，设计了北桥，北桥芯片

北桥：用于处理高速设备，例如CPU，内存。

南桥：用于处理低速设备，例如磁盘，USB，磁盘，鼠标等，由南桥汇总后连接到北桥。



Any problem in computer science can be sovled by another layer of indirection.

计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决



中间层使得应用程序和硬件之间保持相对独立



操作系统：提供抽象接口+管理硬件资源



一个硬盘往往有多个盘面，每个盘分两面，每个面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区，每个扇区512字节，硬盘基本存储单位为扇区；

每个盘面上同心圆周长不一，如果按照每个磁道都拥有相同数量的扇区，那么靠近盘面外围的磁道密度肯定比内圈更加稀疏，比较浪费空间；

但如果不同的磁道扇区数又不同，计算就十分麻烦，为了屏蔽这些复杂的硬件细节，现代的硬盘普遍使用一种叫做LBA的方式，即整个磁盘中所有的扇区从0开始编号，这种编号称为逻辑扇区号；



**地址空间隔离**：通过虚拟地址来解决，将虚拟地址映射成物理地址，保证任意一个程序所能访问到的物理内存区域跟另外一个程序不重叠

32位地址空间：32条地址线(实际36条)，2^32=4294967296(4 GB)，十六进制表示0x00000000~0xFFFFFFFF；

虚拟空间是虚拟的，并不存在，每个进程都有自己独立的虚拟空间，且每个进程只能访问自己的地址空间，这样有效的做到进程隔离



**分段**：一段虚拟地址空间对应一段物理地址空间，不同程序使用的物理地址空间保证不能重合，程序不需要关心物理地址变化，只需按虚拟地址来编写程序；

分段可以解决**地址空间不隔离**和**程序运行地址不确定**问题；但是不能解决内存使用效率问题，因为分段以程序为单位，粒度较大；

**分页**：解决内存使用效率问题；把地址空间人为地分成固定大小的页，每一页大小由硬件决定，或者操作系统决定。基本所有操作系统都用4KB作为页的大小，

虚拟内存的实现需要依靠硬件的MMU部件来进行页映射，MMU一般集成在CPU内部。

![mmu_vm](..\pic\mmu_vm.png)

##### 线程

线程：程序执行流的最小单元，一个标准线程由**线程ID**，当前**指令指针PC**，**寄存器集合**和**堆栈**组成。一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段，数据段，堆等）以及进程级资源（打开文件和信号）

![process_thread](..\pic\process_thread.png)

线程访问权限

- 栈（并非完全无法被其它线程访问，一般可认为私有数据）
- 线程局部存储（Thread Local Storage，TLS），线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限
- 寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有

![thread_private](..\pic\thread_private.png)

线程调度：IO密集型线程（频繁等待），CPU密集型线程（很少等待），IO密集型线程总比CPU密集型线程容易得到优先级的提升。

fork进程速度非常快，因为fork并不复制原任务的内存空间，而是和原任务一起共享一个写时复制(Copy on Write, COW)的内存空间。即，两个任务可以同时自由读取内存，但任意一个进程试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其它的任务使用。

![coyy_on_write](..\pic\coyy_on_write.png)

防止过度优化导致线程不安全：使用volatile关键字试图阻止过度优化，volatile作用：

- 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回
- 阻止编译器调整操作volatile变量的指令顺序



```c++
// 由于CPU可能会乱序执行，C++ new包含两个步骤1. 分配内存 2. 调用构造函数
// 所以 pInst = new T; 除了以上两步，还包含第三步 3. 将内存地址复制给pInst;
// 其中2， 3步可以颠倒的，完全可能出现pInst已经不是NULl了，但对象仍然没有构造完毕。
volatile T* pInst = 0;
T* GetInstance() {
    if (pInst == NULL) {
        lock();
        if (pInst == NULL)
            pInst = new T;
        unlock();
    }
    return pInst;
}

// 因此需要阻止CPU换序，CPU提供barrier指令
#define barrier() __asm__ volatile {"lwsync"}
volatile T* pInst = 0;
T* GetInstance() {
    if (!pInst) {
        lock();
        if (!pInst) {
            T* temp = new T;
            barrier();
            pInst = temp;
        }
        unlock();
    }
    return pInst;
}
```





### 第二部分 静态链接

#### 二，编译和链接

预处理，编译(生成汇编语言)，汇编(根据汇编指令和机器指令对照表一一翻译)，链接

![compile_process](..\pic\compile_process.png)



编译器功能：

- 词法分析(Scanner)：运用一种类似有限状态机的算法可以很轻松的将源代码的字符序列分割成一系列的token，lex程序可实现词法扫描
- 语法分析(Parser)：输入Tokens，产生语法树，yacc工具构造；（编译器编译器）
- 语义分析(Semantic Analyzer)：语法分析只是对表达式语法层面的分析，它不了解这个语句的真正意义。只有通过语义分析才能进行分析。语义分析后整颗语法树的表达式都被标识了类型。
- 中间语言生成
- 目标代码生成与优化



























