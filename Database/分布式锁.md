##### 一，锁的类型：

1. 线程锁：保护临界区域
2. 进程锁：nginx accept 锁 共享内存+信号量
3. 分布式锁：实体也是进程，但是可以是不同机器的进程



##### **二, 什么是分布式锁？**

- 分布式模型下，数据只有一份，需要利用锁的技术控制某一时刻修改数据的进程数
- 分布式锁还是将标记存在内存，只是不是某个进程分配的内存，而是公共内存如Redis，Memcache。



##### 三，分布式锁有哪些特征

1. 互斥性
2. 可重入性：支持一个进程递归获取/释放锁
3. 锁超时（进程crash掉，需要考虑释放分布式锁）
4. 高效，高可用（集群，备份）：加锁和解锁需要高效，保证高可用防止分布式锁失效，可以降级
5. 支持阻塞和非阻塞
6. 公平锁（按获取锁的顺序执行）和非公平锁(无序)



Q: redis与zookeeper如何同步？

A: 以通知的方式进行数据同步，master收到写操作，通知slave；实现最终一致性（最后一样）

zookeeper，zab协议进行数据同步，实现强一致性（一直一样）



**多核编程**：隔离性（运行环境隔离）和统一性（数据统一）

**分布式**：CAP理论(三者占二)

​	任何一个分布式系统都无法同时满足一致性C(Consisstency)，可用性A(Availability)和分区容错性P(Partition tolerance)，最多只能满足两项

​	在大多数应用场景中：都需要牺牲强一致性C来换取系统的高可用性A，系统往往只需要保证最终一致性



##### 四，基于redis实现分布式锁

**redis简介**

主要做缓存数据库，数据结构数据库，kv数据库（通过hash来组织）；MySQL与磁盘交互；

操作redis，实际是操作redis中的数据结构

数据请求方式：请求回应+监听发布

按请求顺序来执行命令，返回也同样



**基于redis的setnx()、expire()方法**

setnx(key, value)，原子操作，如果key不存在，则设置当前key成功，返回1；如果当前key存在，设置失败返回0

expire()，设置过期时间，要注意setnx不能设置超时时间，只能通过expire对key进行设置

使用步骤：

- setnx(lockkey, 1) 返回0，说明占位失败；返回1，占位成功

- expire命令对lockkey设置超时时间，避免死锁（进程挂掉导致无法释放lock）

  ​	`set("lock", value, "NX", "EX", 30)`

  ​	过期时间到后，还有执行完，如何解决？

  ​	set(key, val)  val(四元组)需要记录锁的拥有者；释放锁比较锁的拥有者是否是自己，是才能释放。解铃还须系铃人。

  ​	释放： if get(key) == 四元组  ： delete(key); 两次包，不是原子操作（原子操作：redis事务+lua事务）

  ​	

- 执行完业务代码后，通过delete命令删除key

**基于redis的setnx()、get()、getset()方法做分布式锁**

**基于redlock做分布式锁**

如何标识进程？

pid有最大值MAX(32970)，到达后由从头开始；

微服务：根据端口标识具体服务；

tcp/ip四元组，确定一条连接，还是无法区分 连接先后顺序

ip:port:starttime:pid      starttime ms



##### 五. zookeeper实现分布式锁

> zookeeper is a centralized service for maintaining configurationi information, naming, providing distributed synchronization, and providing group services.

分布式系统通信：zeromq

协调管理功能：zookeeper，比如统一命名，分布式锁，集群，配置中心（web后台操作zk，做配置更新）

数据模型+监听机制，来驱动所有的功能

**1. 数据模型`ls / -R`**

类似文件系统存储方式

节点属性可设置为：

持久的：不给参数，默认为持久

短暂的：`-e`，连接创建的节点断开后数据自动删除

顺序的：`-s`

**2.监听机制`addWatch node`**

可监听节点的变化（创建，删除，值得变化，子节点得变化）

获取锁：无法创建同名短暂得节点（互斥性）

释放锁：delete节点，断开连接自动删除（锁超时）

 

连接断开通过心跳机制来做



监听/lock节点，当/lock失效时都去竞争锁，

Q: 大量的进程要去获取锁，会产生惊群现象，如何避免？

- 创建节点，产生短暂顺序节点（一个进程一个）
- 每一个进程都有一个序号为0，就是它获取锁；序号不为0，只需要监听比它小1的节点即可



**zookeeper流程**

- zk 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务
- zk 的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点
- 子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点
- Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件



ZooKeeper是以Paxos算法为基础分布式应用程序协调服务Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。我们以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，未获取到锁的客户端注册需要注册Watcher到上一个客户端，可以用下图表示。

![zookeeper_lock](..\pic\zookeeper_lock.png)

**zk基本锁**

- 原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。
- 缺点：所有取锁失败的进程都监听父节点，很容易发生惊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。

**zk锁优化**

- 原理：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。
- 步骤：
  - 在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。
  - 判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。
  - 当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。
  - 取锁成功则执行代码，最后释放锁（删除该节点）。

**zk不需要关注锁超时**

Zookeeper不需要配置锁超时，由于我们设置节点是临时节点，我们的每个机器维护着一个ZK的session，通过这个session，ZK可以判断机器是否宕机。如果我们的机器挂掉的话，那么这个临时节点对应的就会被删除，所以我们不需要关心锁超时。



**Curator封装了Zookeeper底层的Api，更加容易对Zookeeper进行操作，封装了分布式锁的功能。**

**InterProcessMutex是Curator实现的可重入锁**







