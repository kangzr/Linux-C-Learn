### 索引介绍

#### 索引是什么

- 帮助MySQL高效获取数据的数据结构，好比一本书的目录，能**加快数据库的查询速度**。
- 一般来说索引本身很大，不存储内存中，因此**索引往往是存储在磁盘上的文件中**，（可能存储在单独的索引文件，可能和数据一起存储在数据文件中）
- 索引可分为：聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等。默认数据结构为B+树

#### 索引的优势与劣势

**优势：**

- 可提高数据的检索效率，降低数据库的IO成本
- 可通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗

**劣势：**

- 索引会占据磁盘空间
- 索引索然会提高查询效率，但是会降低更新表的效率。因为每次增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件



#### 索引类型

**主键索引**：索引列中的值必须是唯一的，不允许空值

**普通索引**：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值

**唯一索引**：索引列中的值必须是唯一的，但允许空值

**全文索引**：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。

**空间索引**：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。

**前缀索引**：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

**单列索引**：

**组合索引**：需要遵循**最左前缀匹配原则（最左匹配原则）**。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用



#### 索引的数据结构选型

##### Hash表

Hash表中Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询效率很高（O(1)），**但不支持范围快速查找**，范围查找只能通过全表扫描方式。因此不适合。

##### 二叉查找树

每个节点最多有2个分叉，左子树和右子树数据顺序左小右大，但是在某种情况会退化成链表，时间复杂度变为O(n)；为了避免这种极端出现，因此有了平衡二叉树

##### 平衡二叉树

属于二叉查找树，且最主要的特征是树的左右两个子树的层级最多相差1。插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。因此其时间复杂度为O(logn)，n为树的高度；以然存在以下问题：

- 树有多高，就需要检索多少次，每次节点读取都对应一次磁盘IO操作。磁盘每次寻道时间为10ms，在表数据量很大时，查询性能会很差（1百万数据量，logn约等于20次磁盘IO，费时20*10=0.2s）
- 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高

##### B树

MySQL的数据是存储在磁盘文件中的，查询处理数据时，**需要先把磁盘中的数据加载到内存中**，磁盘IO 操作非常耗时，所以我们优化的重点就是**尽量减少磁盘 IO** 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。因此便有了B树，是一种多叉平衡二叉树，特点如下：

- B树的节点中存储着多个元素，每个内节点有多个分叉。
- 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
- 父节点当中的元素不会出现在子节点中。
- 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

![b_tree_index](..\pic\b_tree_index.png)

假如我们查询值等于10的数据。查询路径磁盘块1->磁盘块2->磁盘块5。

相比二叉平衡查找树，虽然数据的比较次数并没有明显减少，但磁盘IO次数会大大减少。同时由于比较在内存中进行，耗时可忽略不计。

![b_tree_index_eg](..\pic\b_tree_index_eg.png)

可以优化的地方：

- B树不支持范围查询的快速查找，如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
- 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

因此可讲B树改造成B+树

##### B+树

与B树最主要的**区别**：

B树：非叶子节点和叶子节点都会存储数据。

B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用**双向指针**连接，最底层的叶子节点形成了一个**双向有序链表**。

![B+_tree](..\pic\B+_tree.png)

- B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。
- 所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，放索引的磁盘块锁存放的索引数量是会跟这增加的，相对于B树来说，B+树的树高理论上情况下是比B树要矮的。
- 也存在索引覆盖查询的情况，在**索引中数据满足了当前查询语句所需要的全部数据**，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。

**可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构。**

### MySQL的索引实现

#### MyIsam索引

MyISAM的数据文件和索引文件是**分开存储**的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。

#### InnoDB索引

##### 主键索引（聚簇索引）

每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：

- 在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。
- 如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。
- 如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。

除聚簇索引之外的所有索引都称为辅助索引。在中InnoDB，辅助索引中的叶子节点存储的数据是该行的主键值都。在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。



##### 避免回表

**使用覆盖索引的优化策略减少回表的情况。**



### 联合索引的使用

**联合索引**，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。

试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。

**联合索引的创建原则**，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。

**联合索引的使用**

1. 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
2. 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。





























































