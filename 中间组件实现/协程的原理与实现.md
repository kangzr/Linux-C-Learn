#### 进程，线程与协程

- 进程是最小的资源管理单元，进程间切换需要OS来调度，需要陷入内核，切换内容：页全局目录+内核栈+硬件上下文；多进程隔离性好，比较安全，但切换开销大，数据同步效率低。
- 线程是最小的执行单元或者CPU调度的最基本单位，线程之间的切换需要OS来调度，也即需要陷入内核。切换内容：内核栈+硬件上下文；多线程数据同步效率高，但隔离性差。
- 协程是一种通过函数执行流程的暂停与恢复来实现协作式多任务的程序组件，协程的切换由用户程序控制，没有用户态与内核态之间的切换，切换内容：用户栈或堆。

> coroutine：A coroutine is a function that can suspend its execution (yield) until the given yieldInstruction finishes

协程可子程序（函数）内部中断，转而执行其它子进程，之后能够再从中断点继续执行，就像什么也发生一样。一般子程序的调用入口只有一个，而协程可由多个入口，子程序入口是第一个入口点，子程序中每个yield返回处都可被看作为入口。



##### 协程的优点与缺点：

###### 优点：

- 跨平台，跨体系架构
- 上下文切换开销小，无需内核调度
- 无需原子操作及同步的开销
- 方便切换控制流，简化编程模型
- 协程以同步编程方式，达到异步性能的目的（同步性能不如异步，异步编程不如同步直观）
- 高并发，高扩展，底层本，一个CPU可支持上万协程（但线程数有限）



###### 缺点：

- 无法利用直接多核资源：协程本制上是单线程，不能同时将单个CPU的多个核用上，但是可以和进程配合，将进程挂在指定核心上，便可充分利用核心
- 进行阻塞操作时会阻塞掉整个程序
- 因为协程本制上是单线程，因此不适用于计算密集型场景，一般用于IO密集型。



#### 协程的实现

glibc提供的一个保存上下文的数据结构`ucontext_t`，需要保存运行栈，各种寄存器值，uc_link对应的上下文环境，和信号掩码，如下：

```c
// ucontext.h
/*ucontext有足够空间保存所有的寄存器*/
struct ucontext {
    unsigned long uc_flags;
    // 如果当前context终止后，uc_link指向的context会被恢复执行
    struct ucontext_t *uc_link;
    //运行栈
    stack_t uc_stack;
    // 各种寄存器值
    struct sigcontext uc_mcontext;  
    // 信号掩码
    sigset_t uc_sigmask;  
};
typedef ucontext ucontext_t;
```



glibc中提供了一些供用户操作上下文的接口如下：

```c
// 将当前上下文环境保存到ucp中
// 这些寄存器需要保存到ucontext_t中
// rbx，rbp，r12，r13，r14，r15（用于保存数据）, rdi，rsi，rdx，rcx，r8，r9（用于保存函数参数）
// eip/rip寄存器：指向下一条将要执行的指令，CPU的工作起始就是不断取出它指向的指令，然后执行这条指令，同时指向下一条指令；32位为eip, 64位为rip
// esp/rsp寄存器：指向栈顶；32位为esp，64位为rsp
// 还有一些当前线程的信号屏蔽掩码也需要保存
int getcontext(ucontext_t *ucp);

// 恢复ucp保存的上下文环境，
int setcontext(const ucontext_t *ucp);

// 将ucp结构体修改为执行指定的函数，当此上下文环境之后被激活时（通过setcontext或者swapcontext），
// 函数func会被调用（参数为argc后的参数），当这个函数返回时，ucp->uc_link所指向的上下文环境被恢复
// 如果ucp->uc_link为NULL，则线程退出
void makecontext(ucontext_t *ucp, void(*func)(void), int argc,...);

// 将当前上下文环境保存在oucp中，然后恢复ucp指向的上下文环境。
int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
```



有了上述数据结构和接口函数后，接下来看一个简单的协程实现（[云风版本](https://github.com/cloudwu/coroutine)）

调度器数据结构和协程数据结构如下：

```c
// 调度器数据结构
// 栈的生长方向是从高地址到低地址
// 注意这个数据结构在栈上的分布：从栈的低地址到高地址依次为：stack, main, nco, cap, running, co
struct schedule {
    char stack[STACK_SIZE];  // 栈空间
    ucontext_t main;  // 主协程上下文环境
    int nco;
    int cap;  // 协程容量
    int running;  // 当前运行的是哪个协程
    struct coroutine **co;  // 保存所有协程id即对应的协程
}

// 协程数据结构
struct coroutine {
    /*typedef void (*coroutine_func)(struct schedule *, void *ud)*/
    coroutine_func func;  // 目标函数
    void *ud;
    ucontext_t ctx;  // 上下文环境
    struct schedule * sch;  // 调度器
    ptrdiff_t cap;
    ptrdiff_t size;
    int status;  // 协程状态 DEAD READ RUNNING SUSPEND
    char *stack;  // 栈
}
```



创建和初始化调度器

```c
struct schedule *
coroutine_open(void) {
    struct schedule *S = malloc(sizeof(*S));
    S->nco = 0;
    S->cap = DEFUALT_COROUTINE;   // 协程容量
    S->running = -1;
    S->co = malloc(sizeof(struct coroutine *) * S->cap);
    memset(S->co, 0, sizeof(struct coroutine *) * S->cap);
    return S;
}
```



创建和初始化协程

```c
_co_new(struct schedule *S, coroutine_func func, void *ud) {
    struct coroutine * co = malloc(sizeof(*co));
    co->func = func;
    co->ud = ud;
    co->sch = S;
    co->cap = 0;
    co->size = 0;
    co->status = COROUTINE_READY;  // 初始化状态
    co->stack = NULL;
    return co;
}
int
coroutine_new(struct schedule *S, coroutine_func func, void *ud) {
    struct coroutine *co = _co_new(S, func, ud);
    if (S->nco >= S->cap) {
        // 这里需要扩容
    } else {
        int i, id;
        // 找空闲id
        for (i = 0; i < S->cap; i++) {
            id = (i + S->nco) % S->cap;
            if (S->co[id] == NULL) {
                S->co[id] = co;
                ++S->nco;
                return id;
            }
        }
    }
    assert(0);
    return -1;
}
```



接下来介绍resume（恢复执行）和yield（让出CPU）两个重要接口。

```c
static void
mainfunc(uint32_t low32, uint32_t hi32) {
    struct schedule *S = (struct schedule *)ptr;
    int id = S->running;
    struct coroutine *C = S->co[id];
    C->func(S, C->ud);
    // 如果C->ctx设置uc_link，func返回后恢复uc_link指向的上下文环境
    // 可以注释掉C->ctx->uc_link = &S->main; 并加两天日志观察下两次执行的区别
}

void
coroutine_resume(struct schedule * S, int id) {
    struct coroutine *C = S->co[id];
    int status = C->status;
    switch(status) {
          /*第一次唤醒，需要先getcontext, 再makecontext, 最后swapcontext*/
     	case COROUTINE_READY:
            // 将当前上下文保存到C->ctx
            getcontext(&C->ctx);
            // C->ctx指向S的栈，作为运行时栈，后续操作都在此栈空间进行
            C->ctx.uc_stack.ss_sp = S->stack;
            C->ctx.uc_stack.ss_size = STACK_SIZE;
            // 设置successor context，如果设置为NUll，则func返回后直接退出退出线程
            C->ctx.uc_link = &S->main;
            // 设置C为当前运行的协程，并改变其状态
            S->running = id;
            C->status = COROUTINE_RUNNING;
            uintptr_t ptr = (uintptr_t)S;
            // 修改C->ctx上下文环境
            // C->ctx被激活时，需要调用mainfunc函数，传入2个参数
            makecontext(&C->ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr>>32));
            // C->ctx会激活，会调用mainfunc函数
            swapcontext(&S->main, &C->ctx);
            break;
        case COROUTINE_SUSPEND:  // 只需要swapcontext即可
            memcpy(S->stack + STACK_SIZE - C->size, C->Stack, C->size);
            S->running = id;
            C->status = COROUTINE_RUNNING;
            // C->ctx被激活调用mainfunc函数
            swapcontext(&S->main, &C->ctx);
            break;
        default:
            assert(0);
    }
}
```



yield实现比较简单：获取运行的协程，保存栈，修改协程状态，然后切换上下文

```c
void
coroutine_yield(struct schedule * S) {
    int id = S->running;
    struct coroutine * C = S->co[id];
    _save_stack(C, S->stack + STACK_SIZE);
    C->status = COROUTINE_SUSPEND;
    S->running = -1;
    swapcontext(&C->ctx, &S->main);
}
```



使用例子如下：

```c
struct args {
    int n;
};

static void
foo(struct schedule * S, void *ud) {
    struct args *arg = ud;
    int start = arg->n;
    int i;
    for (i = 0; i < 5; i++) {
        printf("coroutine %d : %d\n", coroutine_running(S), start + i);
        coroutine_yield(S);  // 让出CPU控制权
    }
    // 执行完返回
}
static void
test(struct schedule * S) {
    struct args arg1 = {0};
    struct args arg2 = {100};
    // 创建协程
    int co1 = coroutine_new(S, foo, &arg1);
    int co2 = coroutine_new(S, foo, &args);
    printf("main start\n");
    while (coroutine_status(S, co1) && cortouine_status(S, co2)) {
        coroutine_resume(S, co1);
        coroutine_resume(S, co2);
    }
    print ("end\n");
}
int
main() {
    struct schedule * S = coroutine_open();  // 床架调度器
    test(S);
    coroutine_close(S);
    return 0;
}
```



这里有个关于变量在内存中分配问题记录一下。

````c
struct schedule {
    char stack[STACK_SIZE];  // 栈空间
    ucontext_t main;  // 主协程上下文环境
    int nco;
    int cap;  // 协程容量
    int running;  // 当前运行的是哪个协程
    struct coroutine **co;  // 保存所有协程id即对应的协程
}
// 用malloc分配这个结构体
struct schedule *S = malloc(sizeof(*S));
// 注意&S的地址是在栈上的，这个地址里存的值指向S，这个S为堆上分配空间
// S的地址跟S->stack的地址是一样的，因为stack是第一个元素，然后之后元素入main的地址都是比stack地址要高的

// 这个是协程yield的时候保存栈的操作，注意这个操作都是在S->stack上进行
// char dummy也是在S->stack上分配，而不是在进程地址空间的栈上！！！！太神了
static void
_save_stack(struct coroutine *C, char *top) {
    char dummy = 0;
    assert(top - &dummy <= STACK_SIZE);
    if (C->cap < top - &dummy) {
        free(C->stack);
        C->cap = top-&dummy;
        C->stack = malloc(C->cap);
    }
    C->size = top - &dummy;
    memcpy(C->stack, &dummy, C->size);
}
````



#### NtyCo

[参考](https://github.com/wangbojing/NtyCo)

这是一个纯C版本协程实现，汇编切换，调度器实现，包括服务器端案例，客户端并发测试案例。

一个IO异步操作与协程结合的组件。







#### Libco

Libco 将各个协程使用到的socket句柄都通过epoll进行管理，当某个操作遇到需要网络IO的时候，libco库就把A协程切换出去，换回一个待运行的B协程继续执行，当epoll检测A协程由网络事件到达后，就将A加入待运行协程队列在下次切换时运行