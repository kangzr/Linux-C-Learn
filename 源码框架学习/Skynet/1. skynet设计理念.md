skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。

Skynet解决的主要问题？其优势提现在哪里（**充分利用多核优势**）

#### 多核开发解决方案？

- 多进程

- 多线程
- csp go语言(协程`goroutine+channel`)（加强版的多线程解决方案）
- actor模型 (加强版的多进程解决方案，通过指针进行消息传递，可以启动上千万个actor)



#### 多进程隔离性(运行环境)好，统一性(数据同步)比较差

​	多进程通信方式：socket，共享内存，管道，信号量，`unix`域

**统一性(数据同步)比较差**的解决方案（服务间socket通信问题：`zeromq, rpc`）

- 消息队列`zeromq`：推拉模型，请求回应，监听发布模型，解决**最终一致性问题**
  - 协议问题
  - 断线重连
  - 进程启动顺序问题
  - 负载均衡问题：`fd % 4`， rr，一致性hash
  - 数据同步问题
  
- `rpc grpc`：**解决强一致性问题**

- `zookeeper`：服务协调的问题（核心机制：数据模型+**监听机制**）   （paxos算法，奇数个节点方便投票）
  
  - 配置项管理问题
  - 集群管理 （服务断开）（`redis`哨兵模式），选举master，解决高可用问题(一个服务器断开了，不影响业务)
  - 统一命名问题
  - 状态同步问题
  - 分布式锁问题：多个进程竞争有限资源，解决方案：
    - 数据中心的进程（数据中心存储了**临界资源**）
    - n个竞争资源的进程
    - 进程竞争资源操作：1. 向数据中心请求锁；2. 获取锁，执行相应的逻辑；3. 释放锁（如果在释放锁之前服务断开，解决：过期时间，额外线程 轮询释放锁，其它服务才有能继续使用）**而`zookeeper`解决方式是，可以立马知道服务挂掉，进而释放锁**
    - 数据中心：1. 记录锁，当前使用的对象；2. 主动推送
  
- 拆分：

  功能拆分+热点拆分



#### 多线程 隔离性差(使用锁进行控制，锁类型多，粒度不好控制)，统一性强(数据同步，一个进程内)

如何解决和平衡隔离性与统一性问题？

**多线程通信**：消息队列，pipe，锁

**网络模型**：reactor，`proactor`

**并发模型**：CSP模型+Actor模型

- `actor`：`actor`从语言层面抽象出进程的概念，以actor为并发实体,比如`erlang`（进程，语言层面解决），`skynet`（用框架解决actor），
  - 用于并行计算
  - actor是最基本的计算单元
  - 基于消息计算 （skynet回调函数）
  - actor之间相互隔离（skynet 内存块+lua虚拟机），通过消息(mailbox)进行沟通（skynet消息队列）
- `csp`：go语言为代表，并发实体为`goroutine`

##### 结论：

多进程实体为进程，多线程实体为线程，actor模式实体为actor（语言层面抽象出来的"进程"），go模式实体为`goroutine`（协程）；它们都是在隔离性(运行环境)与统一性(数据统一)之间作取舍平衡，而actor模型在语言层面做运行环境的隔离，数据同步依然需要通过消息来同步，actor模型是加强版的多进程解决方案，进程间通信由socket转为**指针的传递**，从而通信变得更加可靠，同时多进程解决方案中，公共开源组件（消息队列，rpc，zookeeper）解决的问题，在actor模型中处理起来更方便。



#### skynet中的actor模型，skynet中的服务即为actor

1. 结构组成：
   - 隔离的环境（内存块或lua虚拟机）
   - 回调函数，消耗消息，执行actor
   - 消息队列  存储消息

   ![image-20210122110149847](C:\Users\kangzhongrun\AppData\Roaming\Typora\typora-user-images\image-20210122110149847.png)
   
2. 实现
   - logger服务`service-src/service_logger.c`
   - lua服务启动器 `service-src/service_snlua.c`

skynet c+lua，每一个actor都有一块内存块

1. c actor 服务`service_logger.c`：`init, create, release, callback`, 一个内存块
2. lua服务：lua服务启动器`service_snlua.c`，隔离环境就是lua虚拟机，lua虚拟机

skynet中hook `jemalloc`中的分配内存函数

c底层框架，lua业务逻辑，skynet中服务代表actor，每个actor都具有独立的内存块，（通过内存块进行隔离）

c服务隔离的环境为内存块：

![image-20210122110541087](C:\Users\kangzhongrun\AppData\Roaming\Typora\typora-user-images\image-20210122110541087.png)

lua服务隔离的环境就是lua虚拟机：

![image-20210122110756318](C:\Users\kangzhongrun\AppData\Roaming\Typora\typora-user-images\image-20210122110756318.png)



**skynet中 actor运行以及消息调度**

全局消息队列：**存储有消息**的actor消息队列指针（这里需要加锁，每个格子加锁）；

actor消息队列：存储专属actor的消息队列

1. 取出actor消息队列
2. 取出消息，通过回调函数（消息）消费actor中的消息
3. 如果actor消息队列还有消息，就将actor消息队列放入全局消息队列的队尾

![skynet_msg](..\..\pic\skynet_msg.png)

**消息的生产和消费**

生产：

1. actor之间
2. 网络中产生
3. 定时器

消费：仅通过actor回调进行消费

- 从消息队列取消息，并通过回调函数调用  自旋锁；worker线程执行逻辑，尽量不要休眠或切换，worker线程逻辑性比较强
- 没有消息时，使用条件变量进行休眠；定时器+网络线程将其唤醒；
- 为什么actor之间发送消息，为何不需要唤醒worker条件变量？因为actor之间发送消息，则至少有一个worker线程在工作

**skynet中锁的使用：**

- 互斥锁
- 自旋锁
- 读写锁
- 条件变量：phtread_cond_signal会唤醒多个休眠的线程造成**虚假唤醒**，应该用while做循环判断

**skynet中线程：**

- timer
- socket
- worker，work线程尽量不要休眠，所以取全局消息时候用自旋锁；没有消息是才会休眠（消息到来时才唤醒）；actor之间发送消息不需要唤醒worker条件变量？因为当前至少有一个work线程活着。（work线程从全局消息队列中取出（pop）消息调用回调函数来消费消息，根据权重来取消息的数量；回调之后，根据actor消息队列中是否还有actor消息队列添加到全局消息队列队尾）
- monitor

![image-20210122122327425](C:\Users\kangzhongrun\AppData\Roaming\Typora\typora-user-images\image-20210122122327425.png)



线程池+队列和skynet actor区别

- 线程池数量有限，skynet actor可以开上万个
- actor可以根据逻辑功能做更好的调度

skynet最核心工作：解决消息调度，从而实现对actor的调度



1. 阻塞io与非阻塞io区别？

   - 阻塞什么？ 阻塞网络线程

   - 区别在于没有数据到达时，是否立刻返回；

     例如：调用recv/send，read/write时（区别），网络中没有数据时阻塞IO会一直等待；非阻塞IO会立刻返回

   - 什么决定IO是否阻塞？产生fd时是否设置(fnctl)  NONBOLICK

2. redis skynet采用非阻塞的io

socket线程和worker线程通过pipe进行通信

- socket read/write是不是都在一个线程
- epoll_data_t data数据存储时候，用来数据映射 （redis ：data.fd --> connect -->client-->process cmd，skynet使用data.ptr  == socket*）
- 网络事件状态机怎么做
- skynet作为客户端怎么处理



读 都在socket线程

写 spinlock try_spinlock()，拿到锁，（失败：通过管道将数据发送到socket线程，epoll_wait

如果socket线程没有对该io操作，那么直接在worker线程将数据发送



三种fd

1. listenfd
2. 客户端的连接fd
3. skynet作为客户端连接其它服务fd
4. 管道fd

reactor：将连接转化为事件处理，==》 用户处理数据 ==》 到actor



[skynet wiki](https://github.com/cloudwu/skynet/wiki/GettingStarted)

在 skynet 中，用服务 (service) 这个概念来表达某项具体业务，它包括了处理业务的逻辑以及关联的数据状态。

由于 skynet 服务并非独立进程，所以服务间的通讯也可以被实现的高效的多。

由于这些服务同时存在于同一个 skynet 进程下，我们可以认为它们同生共死。在编写服务间协作的代码时，不用刻意考虑对方是否还活着、通讯是否可靠的问题;

大多数 skynet 服务使用 lua 编写，lua 的虚拟机帮助我们隔离了服务

可以把 skynet 理解为一个简单的操作系统，它可以用来调度数千个 lua 虚拟机，让它们并行工作。

每个 lua 虚拟机都可以接收处理其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。

每个 lua 虚拟机，可以看成 skynet 这个操作系统下的独立进程，你可以在 skynet 工作时启动新的进程、销毁不再使用的进程、还可以通过调试控制台监管它们。

skynet 同时掌控了外部的网络数据输入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。



[以下内容引用Skynet源码欣赏](https://manistein.github.io/blog/post/server/skynet/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/)

我们希望自己写的不同的业务逻辑，独立运行在不同的上下文环境中，并且能够通过某种方式，相互协作，最终共同服务于我们的玩家。skynet则为我们提供了这种环境：

- 我们编写好的c文件，在编译成so库以后，在某个时机，调用该so库api的句柄，会被加载到一个modules列表中，一般这样的模块会被要求定义4种接口create，init，signal和release
- 我们要创建一个新的，运行该业务逻辑的上下文环境时，则从modules列表中，找到对应的so库句柄，并且调用create接口，创建一个该类业务模块的数据实例，并且创建一个上下文环境（context），引用该类业务的接口和数据实例，该context会被存放在一个统一存放context的列表中，这种context被称之为服务
- 一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。
- skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，**从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务**（取时加锁），并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的
- socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，**push函数内有加一个自旋锁**，避免同时多条线程同时向一个次级消息队列push消息的惨局。

![skynet_multi_thread](..\..\pic\skynet_multi_thread.png)

从上面讨论可以得出如下结论，我们所写的不同的业务逻辑，可以运行在不同的独立的沙盒环境中，他们之间是通过消息队列来进行交互的。

worker、timer和socket线程里运行的模块，都有机会向特定的服务push消息，他们是消息的生产者，而worker线程内的模块，同时也是消息的消费者（确切的说，应该是那些服务）；

PS：服务模块要将数据，通过socket发送给客户端时，并不是将数据写入消息队列，而是通过管道从worker线程，发送给socket线程，并交由socket转发；

此外，设置定时器也不走消息队列，而是直接将在定时器模块，加入一个timer_node。





skynet每个服务均有一个协程池，lua服务收到消息时，会优先去池子里取一个协程出来，这里为了理解方便，就视为收到一个消息，就创建一个协程吧







#### skynet lua

业务由lua来开发

与底层沟通的用c，计算密集的也需要用c

理解 lua调用c，c调用lua 才能看懂所有的skynet代码

openresty（nginx+lua）

userdata 存储内存块：1. 完全用户数据（由lua创建内存，由lua的gc）；2. 轻量用户数据 由c/c++创建的内存，由c/c++自己释放；

table是lua唯一的数据结构



lua 5.3 文档



redis 用lua实现存储过程

web开发 openresty  B的客户端连接operesty 再转接到A服务器， openstry转阶层将B的协议转换成A的协议，