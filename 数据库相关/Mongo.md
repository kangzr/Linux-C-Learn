### MongoDB

#### 一.  概念

- 基于分布式文件存储的数据库，C++语言编写(MySQL也是用C++开发)的，在高负载情况下，可添加更多节点，保证服务器性能
- 旨在为WEB应用提供可扩展的高性能数据存储解决方案
- 将数据存储为一个文档，数据结构由键值(k-v)对组成



##### CAP理论

NoSQL的基本需求是支持分布式存储，严格一致性和可用性需要互相取舍

CAP理论指出对于一个分布式计算系统来说，不可能同时满足C（一致性）A（可用性）P（分区容错性），并且最多只能满足其中的两项。

对一个分布式系统来说，分区容错是基本需求，否则不能称之为分布式系统，因此必须在C和A之间寻求平衡。

- **一致性(Consistency)** : 更新操作成功并返回客户端后，所有节点同一时间具有相同的数据
- **可用性(Availability)**：只服务一直可用，而且是正常响应时间
- **分区容错性(Partition tolerance)**：指分布式系统在遇到某节点或网络分区故障时，仍然能对外提供满足一致性和可用性的服务



MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的

当存储海量数据时，一台机器无法满足，可将数据分割到多台机器上，一个集群Chunk为一个分片Shard.

##### MongoDB与SQL概念对比

![mongo_sql](..\pic\mongo_sql.png)



#### 2. MongoDB分片



**分片是将数据水平切分到不同的物理节点**。当应用数据越来越大的时候，数据量也会越来越大。

当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。

每个Sharding带一个config(配置)，客户端只需连接mongos (起到对应route作用)，mongos根据config找到对应的sharding;

##### 分片集群结构分布

![mongo_chunk](..\pic\mongo_chunk.png)

- shard：用于存储实际的数据块，实际生产环境中一个shard server角色可由堕胎机器组成一个replica set承担，防止主机单点故障
- config server：mongod实例，存储整个ClusterMetadata，其中包括chunk信息
- router：前端路由，客户端连接，让整个集群看起来像单一数据库，前端应用可透明使用

**为什么使用分片**

- 复制所有的写入操作到主节点
- 延迟的敏感数据会在主节点擦汗寻
- 单个副本集限制在12个节点
- 当请求巨大时会出现内存不足
- 本地磁盘不足
- 垂直扩展价格昂贵



分布式事务需要二阶段定义（先到日志，再到磁盘）保证数据一致，Mongo不支持回滚



##### Mongo基础架构（mongod连接上限6w）

- 单机模式（standalone）
- 高可复制集replica set：一个primary节点(可读可写)，多个secondary节点(只读)
- 可扩展分片集群shard：客户端请求先到mongos，再根据config查询到对应的shard进行操作，shard不够则开辟新的shard

##### Mongo集群

- replica set(副本集): 和主节点数据保持一致（用的比较多）
- master-slave：主机宕机后集群不能再工作，强耦合性（用的比较少）
- sharding：分片，一个shard存储数据的一部分，合起来为完整数据（用的比较多）



#### 3. Mongo关键特性

- documentdb，文档型数据库(格式BSON，二进制JSON)，数据格式无限制；最大16M

- rich query language，丰富的查询功能

- high avaIlability，复制以及高可用性

- horizontal scalability，水平扩展(分片)

- multiple storage engines，多种存储引擎

- 任何属性都可以建立索引

- 使用**内部内存**作为存储工作区,以便更快的存取数据。

  

RDBMS能做的，MongoDB基本都能做



#### 4. Mongo数据模型

**Objectid**： 会自动生成，不需要自己定义，（12进制类型），保证唯一；如果自己定义的话，自己从应用层面保证一致性。一共有四部分组成：时间戳(4个字节)、客户端ID(机器ID3个字节)、进程ID(进程ID 2个字节)、增量计数器（3个字节计数器）

**内嵌文档**：（内嵌层次有限制），mysql则需要建多个表，然后通过外部来关联

**chunk迁移**（limit64M）： 数据从一个分片切到另一个分片，把数据从shard1 move到shard2，先move成功再remove，可能会产生孤儿数据





#### 5. Mongo存储引擎

- **mmap引擎**：读写锁，内存，**Juoranal日志**（数据先写到这里，顺序写，二阶段提交，每次重启都会flush journal，如果没到juoranal，数据就丢了，只要到了jouranal就不会丢失，保存变更的记录，find不会记录；进行批量写入提高性能（每1ms flush一次）；适合写的节点
- in-memory：适合读的节点
- wiredtiger：内存要求低，但是要耗费更多cpu的计算，适合作备份节点

不同的节点可以使用不同的引擎，比如mmap（写），in-memory（读）， wiredTiger(备份节点)，锁级别影响读写性能



#### 6. Mongo管理与监控

- 备份与恢复：mongodump和mongostore

- 导入和导出：mongoimport 和mongoexport

- 监控：mongostat和mongotop（mongodb查询缓慢，会出现大量慢日志，cpu，io负载高）

  mongostat：mongodb自带的状态检测工具，在命令行下使用，会间隔固定时间获取mongdb的当前运行状态，并输出。

  mongotop：提供方法跟踪一个mongdb实例，查看哪些大量的时间花费在读取和写入数据。



#### 7. Mongo索引

索引是为了解决数据搜索效率低下引入的一种特殊的数据结构。索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。简单的说，索引就是将`文档`按照某个（或某些）字段顺序组织起来，以便能根据该字段高效的查询。

每个文档在经过底层的存储引擎持久化后，会有一个位置信息，通过这个位置信息，就能从存储引擎里读出该文档。比如[mmapv1引擎](https://docs.mongodb.org/manual/core/mmapv1/)里，位置信息是`『文件id + 文件内offset 』`， 在[wiredtiger存储引擎](https://docs.mongodb.org/manual/core/wiredtiger/)（一个KV存储引擎）里，位置信息是wiredtiger在存储文档时生成的一个key，通过这个key能访问到对应的文档；

**索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在 磁盘上**

- 单字段索引：`db.person.createIndex({age: 1})`，1升序
- 复合索引：`db.person.createIndex({age: 1, name: 1})`，第一个字段相同，再排第二个
- 多key索引
- 稀疏索引：仅包含具有索引字段的文档的条目，即使索引字段包含空值也是如此。可跳过那些索引键不存在的文档
- 唯一索引：用于确保索引字段不存储重复的指，即强制索引字段的唯一性
- TTL索引：每个文件设置一个超时时间，文档到达预设的老化程序后被删除
- 全文本索引：全文检索对每个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找结果反馈给用户的检索方式
- 地理空间索引：2dsphere索引（用于地球表面类型的地图）；2d索引（用于平面地图和时间连续的数据）
- 使用GridFS存储文件：用来存储大型二进制文件

`explain: 提供查询信息，使用索引即查询统计等`

`hint: 强制指定索引`





#### 9. MongoDB操作

**创建一个新的数据库**：MongoDB 用 use + 数据库名称 的方式来创建数据库。use 会创建一个新的数据库，如果该数据库存在，则返回这个数据库。`use mydb`

**查看数据库列表**：`show dbs`

- mongod: mongod是处理MongoDB系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行mongod命令意味着正在启动MongoDB进程,并且在后台运行。
- mongo： 它是一个命令行工具用于连接一个特定的mongod实例，传递数据库存储路径，默认是"/data/db" 端口号 默认是 "27017"



#### 10.Mongo复制(副本集)

将数据同步在多个服务器的过程，复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提供了数据的可用性，并保证了数据的安全性，复制还允许从硬件故障和服务中断中恢复数据

**什么是复制？**

- 保证数据的安全性
- 数据高可用（24 * 7）
- 灾难恢复
- 无需停机维护（如备份，重建索引，压缩）
- 分布式读取数据

**Mongo复制原理**

mongodb的复制至少需要两个节点，其中一个是主节点，负责处理客户端的请求，其余的都是从节点，负责复制主节点上的数据。

mongodb常见的节点搭配：一主一从，一主多从。主节点记录在其上的所有操作oplog，从节点定期 轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点数据与主节点的最终一致性。

**副本集特征**

- N个节点的集群
- 任何节点可作为主节点
- 所有写入操作都在主节点上
- 自动故障转移
- 自动恢复





#### 11. 关系型数据库和非关系数据库

##### **1. 关系型数据库SQL(RDBMS)**

最典型的数据结构是**表**，由二维表及其之间的联系组成一个数据结构。必须具备**ACID特性**，Atomic(原子性)，Consistency(一致性), Isolation(隔离型)，Durability(持久性)。代表：mysql，mariadb，oracle，postgre sql

**优点：**

- 易于维护，使用表结构，格式一致
- 使用方便，SQL语言通用，可用于复杂查询

**缺点：**

- 读写性能差，尤其对于海量数据的读写
- 固定表结构，不够灵活，可扩展性差
- 高并发性能差（硬盘IO瓶颈）

##### **2. 非关系型数据库NoSQL**

是一种数据结构化存储方式的集合，可以是文档或键值对，**属于分布式的**，不保证ACID。代表：mongodb，redis，couchdb等

**优点：**

- 格式灵活，支持key-value，文档形式，图片形式等，使用灵活，适用场景广泛，（关系型数据库仅支持基础类型）
- 速度快，可使用硬盘或随机存储器作为载体，（sql仅支持硬盘）
- 高扩展性，（支持横向扩展）
- 成本低，nosql部署简单，基本都是开源软件
- 支持高性能并发读写，可在海量数据中快速查询

**缺点：**

- 不支持sql，学习使用成本高
- 无事务处理
- 数据结构复杂，复杂查询方面欠缺



##### 3. 关系型和非关系型数据库的比较（以下有些不适用mongo；主要以redis为对比）

- 成本：Nosql简单易部署，基本属于开源软件，不需要像Oracle那样花费大量成本购买使用。

- 查询速度：Nosql数据库将数据存储在缓存中？？，而且不需要经过SQL层解析，关系型数据库将数据存储在硬盘中，自然查询速度不如NoSQL数据库

- 存储数据格式：Nosql的存储格式为k，v形式，文档形式，图片形式等，可以存储基础类型以及对象或者

- 扩展性：关系型数据库由类似join这样的多表查询机制的限制，导致扩展很艰难；NoSQL基于键值对，数据之间没有耦合性，所有非常容易水平扩展

- 持久存储：Nosql不适用与持久存储，海量数据的持久存储，还需要关系型数据库

- 数据一致性：非关系型数据库一般强调的是数据最终一致性，而关系型数据库为强一致性，因此非关系型数据中读到的有可能是处于一个中间态的数据。

- 数据存储结构：

  MySQL每个数据库存放在一个与数据库同名的文件夹中；MyISAM：存储引擎，数据文件类型就包括.frm .MYD .MYI；InnoDB存储引擎: .frm .idb

  MongoDB：默认数据目录/data/db，负责存储所有的mongodb的数据文件



#### 12. JSON&BSON

JSON是一种轻量级的数据交换格式。完全独立于编程语言的文本格式来存储和表示数据。支持字符串、数字、对象、数组等类型。


BSON是一种计算机数据交换格式，主要被用作MongoDB数据库中的数据存储和网络传输格式。它是一种二进制表示形式，能用来表示简单数据结构、关联数组（MongoDB中称为“对象”或“文档”）以及MongoDB中的各种数据类型。BSON之名缘于JSON，含义为Binary JSON（二进制JSON）。



应用场景：聊天记录，大量评论

越久远的数据，访问次数越少，放到访问越慢的磁盘中（内存 --> 磁盘）



mongod：

写入的速度跟redis差不多

读出的速度跟mysql差不多

- 博客存储（写的次数少，读的次数多）

- 日志系统（写入次数多，读的次数少） --- MongoDB（集中式日志kafka: 消息队列, 接受数据 当日志很多时候kafka可以存储一部分，起到消峰作用 +  mongdb）

- 一起写文档（读写一致，强实时）



canal从mysql同步到redis：从redis里面读，从mysql里面写



mongodb在启动时，需要指定文件存到什么地方。

`mongod --dbpath=db --bind_ip=0.0.0.0 --logpath=log/db.log &`



读写比mysql快？

Mongo数据存储在哪里？



MySQL中字段要事先定义好，固定大小

MongoDB不需要事先定义字段，不固定大小，比较灵活



3.2版本之前MMAPV!有，4.0以后废弃



**wiredTiger 3.0之后引入，4.0以后默认使用**

索引存储磁盘，数据首先写到内存中，将久远的数据存储到SSD中，更久远的数据存储到机械硬盘中。（可以配置何时写入）

(wiredTiger实现) 默认60s或者文件达到2G，就把内存数据同步到磁盘中



**MyISAM引擎**

索引存储在磁盘，**数据直接存储到磁盘**，



MySQL：explain查看执行语句（判断是否全表扫描，type: ALL）

MongoDB：explain  indexFilterSet 可以看有没有索引



#### Mongo选举机制

多少哥mongo实例

#### 复制集概述

MongoDB复制集是指MongoDB实例通过复制并应用其他实例的oplog达到数据冗余的技术。MongoDB复制集一般由一个主服务器（Primary）和若干个备服务器（Secondary）组成。其中Primary用于处理客户端的请求，通过Primary将数据写入；Secondary从Primary同步数据，保存副本。当Primary服务器崩溃时，MongoDB复制集通过选举机制将其中一个Secondary服务器升级为Primary，保证复制集的高可用。

#### 选举机制

MongoDB节点之间维护心跳检查，主节点选举由心跳触发。



#### 心跳检查

MongoDB复制集成员会向自己之外的所有成员发送心跳并处理响应信息，因此每个节点都维护着从该节点POV看到的其他所有节点的状态信息。节点根据自己的集群状态信息判断是否需要更换新的Primary。

在实现的时候主要由两个异步的过程分别处理心跳响应和超时，抛开复杂的条件检查，核心逻辑主要包括：

\- Secondary节点权重比Primary节点高时，发起替换选举；
\- Secondary节点发现集群中没有Primary时，发起选举；
\- Primary节点不能访问到大部分(Majority)成员时主动降级；

降级操作会断开链接，终止用户请求等。

#### 选举发起

发起选举的节点需要首先做一些条件判断，比如节点位于备选节点列表中、POV包含复制集Majority等，真实情况的条件判断更加复杂。然后将自己标记为选举过程中，并发起投票请求。

#### 投票

投票发起者向集群成员发起Elect请求，成员在收到请求后经过会一系列检查，如果通过检查则为发起者投一票。一轮选举中每个成员最多投一票，在PV0中用30秒“选举锁”避免为其他发起者重复投票，这导致了如果新选举的Primary挂掉，可能30秒内不会有新的Primary选举产生；在PV1中通过为投票引入单调递增的Term解决重复投票的问题。

如果投票发起者获得超过半数的投票，则选举通过成为Primary节点，否则重新发起投票。

#### 注意：

- MongoDB选举需要获得大多数投票才能通过，在一轮选举中两个节点得票相同则重新选举，为避免陷入无限重复选举，MongoDB建议复制集的成员个数为奇数个，当Secondary节点个数为偶数时，可以增加一个Arbiter节点，。
- PV0版本中，所有成员都可以投否决票，一个否决票会将得票数减少10000，所以一般可以认为只要有成员反对，则该节点不能成为Primary。PV1版本取消了否决票。
- 选举过程中，复制集没有主节点，所有成员都是只读状态。



#### 容灾

#### 分布式



