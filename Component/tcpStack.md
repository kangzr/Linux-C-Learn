

### 1. 用户态协议栈及实现

**网卡属于协议栈的哪一层？具体作用是？**

不属于任何一层，网卡是处理光电信号与数字信号之间的转化，即A/D, D/A转化



协议栈：一层一层往外包



物理层: 传输物理信号（光信号/电信号）；

数据链路层：传输数字信号01 ； （以太网协议）

网络层：IP协议

传输层：TCP/UDP协议

用户层：



mac地址只在局域网(子网)内有用。（每经过一个网关设备都会被修改）

![image-20201013090451246](C:\Users\kangzhongrun\AppData\Roaming\Typora\typora-user-images\image-20201013090451246.png)



劫持网卡数据后，ping不通了（icmp），因为没有arp（映射ip地址和mac地址）了（arp -a 找不到对应的ip了） （ping会更新arp表）

**实现icmp/arp协议**





---





#### netmap

- netmap是一个高性能收发原始数据包的框架，由Luigi Rizzo等人开发，包含了内核模块以及用户态库函数，

  其目标是：不修改现有操作系统软件以及不需要特殊硬件支持，实现用户态和网卡之间数据包的高性能传递。

- netmap通过自带的网卡驱动直接接管网卡，运行时申请一块固定的内存池，通过mmap实现网卡数据包与内存之间的

  映射。



先了解netmap实现了哪些功能？？？

netmap.ko

劫持之后所有改网卡上的网络服务都用不了了。



现在网卡都使用多个buffer来发送和接受packet，并有一个叫NIC ring的环形数组，NIC ring是静态分配的，它的槽指向mbufs链的部分缓冲区buffers

netmap内存映射网卡的packet buffer到用户态，实现了自己的发送和接受报文的`circular ring`来对应网卡的ring，使用netmap时，程序运行在用户态，

即使出了问题也不会crash操作系统。



netmap使用poll等待网卡的文件描述符的事件(可读可写)；

netmap会建立一个字符设备`/dev/netmap`，然后通过`nm_open`来注册(接管)网卡为netmap模式

（网卡进入netmap模式后，ifconfig是看不到网卡统计信息变化的，ping也不同，wireshark也抓不到报文，因为内核协议栈被旁路了）

零拷贝实现：？



网卡中有一个环形数组NIC ring，它的槽指向mbufs链的部分缓冲区，netmap映射网卡packet_buffer到用户态。



数据包池(可理解为已经申请好的内存，由内核维护)，数据到达，内核分配一个数据包(内存)包住数据，数据包池通过mmap技术映射到用户空间

用户态程序通过`netmap_if`获取接收/发送环`netmap_ring`，进行数据的获取/发送





#### `netmap`优势

- 性能高

  - 数据包不走传统内核协议栈，不需要层层解析，减少处理数据包的时间；
  - 用户态直接与网卡的接受和发送环交互，可减少系统调用
  - 不需要进行数据包的内存内配，采用**数据包池**(内核维护？)，有数据到达时，直接从数据包池中取出一个数据包，然后将数据放入此数据包`pkt_buf`中，再将数据包的描述符放入接收环`netmap_ring`中。
  - 减少数据copy次数，数据包(内存)采用`mmap`技术映射到用户态，实现零拷贝。

- 稳定性高

  网卡寄存器数据的维护都在内核模块进行，用户不会直接操作寄存器。所以用户态操作时，不会导致操作系统崩溃

- 亲和性

  可采用`cpu`亲和性，实现`cpu`和网卡绑定，提高性能

- 易用性好

  API操作简单，用户态只需要调用ioctl函数即可完成数据包收发工作

- 与硬件解耦

  不依赖硬件，只需要对网卡驱动程序稍微做点修改就可使用。传统网卡驱动将数据包传送给内核协议栈，而修改后的数据包直接让如**netmap_ring**供用户使用



#### 应用场景

- 抓包程序

- 高性能发包器

- 虚拟交换机：虚拟交换机场景下，使用`netmap`可以实现不同网卡间高效数据转发，

  ​						将一个网卡数据放到另一个网卡上时，只需要将接收环(`netmap_ring`)中的packet描述符放入发送环？不需要copy数据，实现数据零拷贝



防火墙是再协议栈上实现的。



**为啥不用偏移，结构强转自动处理？？？**

全部过完再总结



---



### 2. 用户态协议栈之tcpip滑动窗口 拥塞慢启动

TCP：

1. 数据可靠
2. 传输效率不低
3. 顺序

确认机制，

1. 如何做到一对一
2. 状态机





三次握手，如何实现三次握手？

**syn队列(半连接队列)**：第一次发syn给服务端的client，服务端用队列一个节点保存一个客户端

​	（ddos攻击，syn floor，因为syn队列有长度限制，会导致有用的连接进不来）

**accept队列(全连接队列)**：三次握手完成后将队列1中响应的节客户端节点move到这里



`listen(fd, backlog);`  backlog?

1. backlog表示syn队列的长度   (mac)
2. syn + accept共同的长度   





`clientfd = accept(listenfd, addr);`

accept函数作用：（当accept队列为空时，则阻塞直到有数据，通过条件变量实现）

1. 从accept队列里取出一个节点
2. 为该节点分配一个fd，将节点与fd一一对应



节点的**生命周期**有多长？（tcp控制块，从listen状态 --> time_wait状态）

1. tcp 11个状态保存在哪里
2. fd --> 节点一一对应（五元组）



端口只有65535，为什么并发能做到上百万？

fd --> (sip源ip, dip, sport源端口, dport, proto协议)；fd通过五元组判断客户端的唯一性；



`send(fd)`   通过fd找到五元组并找到对应的客户端



































