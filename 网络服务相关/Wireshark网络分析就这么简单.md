Q：两台服务器A和B，B的子网掩码本应该为255.255.255.0，不小心配成了255.255.255.224，他们还能正常通信吗？

在服务器B上Ping服务器A的步骤：

- 服务器B通过ARP广播查询默认网关的MAC地址，因为B根据自己的子网掩码计算出A属于不同的子网，跨子网通信需要默认网关转发，因此需要获取其MAC地址
- 默认网关向B回复自己的MAC地址
- 服务器B把ping数据包发送至默认网关，默认网关向服务器A进行转发，是为下一跳
- 



 采用tcpdump抓包，使用Wireshark来分析

```shell
# 只抓eth0上每个包的前80个字节
$ tcpdump -i eth0 -s 80 -w ~/tcpdump.cap
# 只抓与10.32.200.131通信的包
$ tcpdump -i eth0 host 10.32.200.131 -w ~/tcpdump.cap

```



抓包小技巧

```shell
pint <IP> -n 1 -l 1   # 可以找到 Data(1byte)即为对应的包
```



##### MSS + TCP/IP头 == MTU

##### 发送窗口和MSS的关系：前者决定一次能发多少字节，后者决定这些字节要分多少个包发完。比如发送窗口为16000，如果MSS为1000字节，则需要发送16个包

##### 发送方在一个窗口发出n个包，是不是就收到n个确认包？

不是，TCP采用累计确认方式

##### TCP Windows Scale跟接收窗口的关系？

Window Scale放在TCP头之外的Options，Window Scale作用是向对方声明一个Shift Count（n），真正窗口大小= 2^n * 窗口大小

导致网络拥塞的数据量称为拥塞点，发送方应尽量把发送窗口控制在拥塞点以下，这样就能避免拥塞。那么发送方如何知道拥塞点呢？

##### 拥塞窗口如何维护？

- 连接刚建立时，发送方对网络状况一无所知，会先把拥塞窗口初始值设的很小，比如2个MSS，或者4个
- 如果没有发生丢包，则增大拥塞窗口，每收到n个包的确认，将拥塞窗口增加n个MSS，由于基数低，因此传输速度还是比较慢，称为**慢启动**
- 慢启动一段时间后，拥塞窗口达到了一个较大值，触碰拥塞点的概率也大了，因此不再采用翻倍的慢启动法，而是每RTO增加一个MSS，这个过程称为**拥塞避免**。拥塞临界窗口一般为之前发生过拥塞的值，如果没有拥塞过，则取相对较大的值。



##### 延时确认与Nagle算法

并没有提高性能，而是提高传输效率，减轻网络负担。



Nagle算法用于解决Silly Window syndrome 小包问题















