#### Proactor异步非阻塞模式

 ASIO再Linux平台下基于epoll，但epoll只支持reactor模式，ASIO通过封装在epoll上实现了proactor，ASIO中的所有异步操作都是基于io_service实现的，io_service是ASIO的任务队列，并且其负责调用epoll_wait等待IO事件的到来，



#### Reactor模式：

- 基于非阻塞IO多路复用，
- 告诉调用者什么时候事件到来，需要进行什么操作；
- 首先reactor模式依赖于epoll这样的io多路复用机制,能监听大量文件描述符的读写,在有可读写时发生超时或收到信号时从阻塞状态退出,用户程序根据发生的事件进行相应的处理. **本质上来看reactor模式还是同步模式**,当前进程一直监控一个事件集合,可读就读,可写就写.
- 例如：Reactor中注册读事件，那么文件描述符可读时，需要调用者自己调用read系统调用读取数据
- 

#### Proactor模式：

- 基于异步IO，
- 针对事件对应的操作完成，通知调用者，一般通知方式为异步回调；
- 但是proactor模式就不一样了,本质上是异步模式,只要注册了读事件处理函数,就可以继续做其它事情了, 也就是说不需要当前进程再处理读和写操作了,只需要在注册事件处理函数的时候提供一个缓冲区,操作系统就会在可读或可写时将读写完成,然后将数据拷贝到注册的缓冲区,然后通知用户程序事情干完了, windows下的iocp能提供很好的异步io支持.
- proactor模式需要提供异步接口如 async_write 和 async_accept等,并且可以由一个对象io_context来管理io事件,但是不能像reactor一样由一个线程来管理事件并且处理事件.proactor模式要能够在注册完事件之后马上就能够开始等待处理,并且在底层完成读写操作将数据拷贝到提供的缓冲区.
- 例如：注册读事件，同时提供一个buffer用于存储读取的数据，那么Preactor通过回调函数通知用户时，用户无需在调用系统调用读取数据，因为数据已经存储在buffer中了；



两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个 IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下 (Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。

使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。
Reactor框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要 向一个SOCKET写数据，那么当该SOCKET可以接收数据的时候，你的操作就会被调用；而Proactor框架中用户定义的操作是在实际操作之后调用 的。比如你定义了一个操作要显示从SOCKET中读入的数据，那么当读操作完成以后，你的操作才会被调用。



#### Boost.Asio如何实现Proactor模式？











