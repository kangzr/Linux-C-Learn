Linux中内存都以页（4K）为单位进行管理，当内核需要内存就调用如：kmem_getpages这样的接口（底层调用__alloc_pages()分配内存）

内核使用伙伴算法来管理页的分配，slab也是向内核申请一个个页，然后再对页框做管理来达到分配小存储区的目的（处理同一页框中分配小存储器区）



Slab是一种内存分配器，通过将内存划分不同大小的空间分配给对象使用来进行缓存管理，应用于内核对象的缓存。



##### Slab两个作用

- Slab对小对象进行分配，不用为每个小对象分配一个页，节省了空间
- 内核中一些小对象创建析构很频繁，Slab对这些小对象做缓存，可以重复利用一些相同的对象，减少内存分配次数

```shell
cat /proc/meminfo
Slab和SReclaimable项

slabtop查看slab占用情况
```



[参考Slab机制](https://www.jianshu.com/p/95d68389fbd1)

#### 内部碎片和外部碎片

**外部碎片**：需要申请连续的5个页框(4K)，但这段内存找不到连续5个页框，就会去另一段内存上寻找；久而久之会造成页框浪费；Linux内核中使用伙伴算法解决

**内存碎片**：如果只需要申请几十个字节，内核也是给我们分配一个页，每个页4K，因此造成大量浪费，这种称为内存碎片；Linux内核引入Slab机制解决



#### Slab分配机制

Slab分配器是基于对象（内核中数据结构）进行管理的，相同类型对象归为一类，每当要申请这样一个对象时，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存载该列表中，而不是直接返回给伙伴系统，从而避免内部碎片，slab分配器并不丢弃已经分配的对象，而是释放并将其保存载内存中。slab分配对象时，会使用最近释放的对象的内存块，因此其驻留载cpu高速缓存中的概率会大大提高

![linux_slab_cache](..\pic\linux_slab_cache.png)



kmem_cache是一个cache_chain的链表，描述了一个高速缓存，每个高速缓存包含了一个slabs的列表，这通常是一段连续的内存块。

存在3种slab：slabs_full(完全分配的slab),slabs_partial(部分分配的slab),slabs_empty(空slab,或者没有对象被分配)。

slab是slab分配器的最小单位，在实现上一个slab有一个货多个连续的物理页组成（通常只有一页）。

单个slab可以在slab链表之间移动，例如如果一个半满slab被分配了对象后变满了，就要从slabs_partial中被删除，同时插入到slabs_full中去。

```c
struct kmem_cache {
    
}
```























