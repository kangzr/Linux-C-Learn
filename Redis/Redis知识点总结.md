### Redis总结



##### Redis是一个基于内存的高性能key-value数据库，基于c语言开发

##### Redis基本数据结构

- **字符串SDS**：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。
- **链表linkedlist**：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。
- **字典hashtable**：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了**服务的可用性**，rehash的过程不是一次性完成的，而是渐进式的。
- **跳表skiplist**：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。
- **整数集合intset**：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。
- **压缩列表ziplist**：压缩列表是为节约内存而开发的顺序性数据结构，可以包含多个节点，每个节点可以保存一个字节数组或者整数值。



- 数据类型不是直接存储，而是通过redisObject对象进行存储
- redis通过**encoding属性**设置对象的编码形式来提升灵活性和效率
  - 字符串对象：int整数、embstr编码的SDS，raw简单动态字符串
  - 列表对象list：ziplist，linkedlist
  - 哈希对象：ziplist，hashtable
  - 集合对象：inset，hashtable
  - 有序集合对象：ziplist，skiplist



##### Redis相比memcached有哪些优势？

- memcached所有的值都是简单的字符串，redis支持更为丰富的数据类型
- redis的速度比memcached快很多
- redis支持持久化



##### Redis为什么选择单线程，单线程如何解决并发问题，以及为何如此快？

- 基于内存操作，CPU不是瓶颈，其瓶颈在于内存大小和网络带宽。既然CPU不是瓶颈，单线程实现更加简单。（为什么选择单线程）

- redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。（单线程如何解决并发问题）

 为何如此快？

- 完全基于内存，绝大部分请求是纯内存操作，数据结构类似hashmap，时间复杂度为O(1)
- C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高
- 采用单线程，避免线程切换带来的上下文切换，以及竞争条件带来的各种锁机制。
- 使用IO多路复用模型
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请



**为什么Redis6.0之后改用多线程呢？**

redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。

这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。



**Redis三种不同删除策略**

- 定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作；
  - 优点：对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期健所占用的内存
  - 缺点：对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量
- 惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键
  - 优点：对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。
  - 缺点：对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。
- 定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略。
  - 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
  - 定时删除策略有效地减少了因为过期键带来的内存浪费。

**Redis内存淘汰策略**

- noeviction：不删除策略，达到最大内存限制时，如果需要更多内存，直接返回错误信息
- allkeys-lru：所有key通用，优先删除最近最少使用的key
- volatile-lru：只限于设置了expire的部分，优先删除lru
- allkeys-random：所有key通用，随机删除一部分key
- volatile-random：只限于设置了expire的部分，随机删除一部分key
- volatile-ttl：只限于设置了expire的部分，优先删除剩余时间TTL短的key

**Redis持久化方案**

为什么需要持久化？Redis是内存型数据库，如果不持久化，服务器宕机，数据机会丢失。因此需要将数据保存到磁盘中。	

Redis服务器默认开启RDB，关闭AOF；开启AOF需要配置appendonly yes

- RDB
  
  原理是将某个时间点上的数据状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上，所以即使redis崩溃，只要RDB文件在，就可以恢复数据。可以通过SAVE/BGSAVE来生成RDB文件。其中SAVE会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求。BGSAVE会fort一个进程，由子进程去负责生产RDB文件，父进程可以继续处理命令请求，不会阻塞进程。
  
  - 优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。与AOF相比，其最重要的优点之一是对性能的影响相对较小
  - 缺点：致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差。
  
- AOF

  AOF的原理是用过保存Redis服务器所执行的命令来记录数据库状态。通过追加，写入，同步三个步骤来实现持久化机制。

  - 与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大，恢复速度慢，对性能影响大。

**Redis内存模型**

- used_memory：Redis分配器分配的内存总量，包括虚拟内存（swap）
- used_memory_rss：Redis进程占据操作系统的内存，与top/ps命令看到的一致。除了分配器分配的内存外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等。但不包括虚拟内存
- mem_fragmentation_ratio：内存碎片比率，used_memory_rss / used_memory
- mem_allocator：Redis使用的内存分配器，编译时指定，默认jemalloc。

**Redis内存划分**

- 数据：作为数据库，数据是最主要的部分
- 进程本身运行需要的内存：Redis主进程本身运行肯定需要占用内存，如代码、常量池等等，这部分不是由jemalloc分配，不会计入used_memory中
- 缓冲内存：缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。
- 内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的，不会统计在used_memory中

**Redis主从复制**

- 复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的
- 复制主要实现了数据的多机备份，以及对于读操作的**负载均衡**和简单的**故障恢复**
- 缺陷：**故障恢复无法自动化**；写操作无法负载均衡；存储能力受到单机的限制。

**Redis哨兵模式**

哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。

- 在复制的基础上，哨兵实现了自动化故障恢复。
- 缺陷：写操作无法负载均衡，存储能力受到单机限制



**Redis热key是什么？以及如何解决？**

- 热key：突然有大量（几十万）的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。
- 解决方案：1.提前将热key分散到不同的服务器上，分散压力；2.加入二级缓存，提前加载热key数据到内存，如果redis宕机，走内存查询



**Redis缓存击穿**

- 现象：单个key并发访问过高，过期时导致所有请求直接打到db上。
- 解决：1. 加锁更新，当访问key失效时，先用setnx锁住key，去db查询回来再更新缓存，后面的请求直接读缓存；2. 将过期时间组合写在value中，通过异步方式不断刷新过期时间。

<img src="../pic/redis_cache1.png" alt="redis_cache1" style="zoom:50%;" />

**Redis缓存穿透**

- 现象：当查询一个缓存中不存在的key时，每次请求都会打到DB，就像缓存不存在一样。
- 解决：布隆过滤器

<img src="../pic/redis_cache_2.png" alt="redis_cache_2" style="zoom:50%;" />

**Redis缓存雪崩**

- 现象：大量key失效，一大波请求瞬间到来，全都打在db上，造成数据库连接异常
- 解决：限流，分散key的缓存时间；1. 加锁排队；2. 二级缓存; 3.针对不同的key设置不同的过期时间。

**Redis分布式锁**

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放

**Redis中海量数据的正确操作方式**

利用SCAN系列命令（SCAN，SSCAN，HSCAN，ZSAN）完成数据迭代

**Redis事务机制**

redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：

- 服务端收到客户端请求，事务以MULTI开始
- 如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令
- 当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端
- WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。





QUESTION？

**Redis有哪些数据结构？**

**使用过Redis分布式锁么，它是什么回事？**

**假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

**使用过Redis做异步队列么，你是怎么用的？**

**如果有大量的key需要设置同一时间过期，一般需要注意什么？**

**Redis如何做持久化的？**

**Pipeline有什么好处，为什么要用pipeline？**

**Redis的同步机制了解么？**

**是否使用过Redis集群，集群的原理是什么？**



Redis是一个Key-Value存储系统；

Redis将数据存储于内存中，或被配置为使用虚拟内存，这两种方式都可以实现**数据持久化**。

提供基于TCP的协议以及操作丰富的数据结构

定位于一个内存数据库，正因为内存的快速访问特性，才使得Redis能够有如此高的性能，能轻松处理大量复杂数据结构





Redis是一个开源的，使用ANSI C语言编写、遵循BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言API；

具有以下优势：

- 性能极高：Redis纯内存读写，读的速度110,000次/s，写的速度81000次/s
- 丰富的数据类型：Redis支持二进制案例的String、List、Hash、Set及Ordered Set数据类型操作
- 原子：Redis的所有操作都是原子性的，单个操作是原子性，多个操作也支持事务/原子性，通过MULTI和EXEC指令包起来
- 丰富的特性：Redis还支持publish/subscribe、通知、key过期等特性



**丰富的编码格式的好处？**

通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。

举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：因为压缩列表比双端链表更节约内存， 并且在元素数量  较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
但是，随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。

**SDS优势，为什么不直接用C字符串？以及SDS如何扩容**

获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) ，和 C 字符串不同， SDS 在 len 属性中记录了本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)，通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。

设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。

**为什么跳表要用压缩列表指向头指针？**

但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳表进行处理， 比如快速访问跳表的表头节点和表尾节点， 又或者快速地获取跳表节点的数量（也即是跳表的长度）等信息。

**新增数据时，如何确定跳表节点多少层？**

每次创建一个新跳跃表节点时，根据幂次定律（经济学家提出，越大的数出现的概率越小），随机生成一个介于1和32之间的值作为level的数组大小，这个大小就是层高度

**如何在遍历跳表时快速得到当前元素排名？**

遍历过程中所有的跨度(span)之和即为当前rank

**zset何时使用ziplist何时使用skiplist编码？**

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist

- 有序集合保存的元素数量小于128（可配置修改）
- 有序集合保存的所有元素成员的长度都小于64字节

**为什么有序集合需要同时使用跳表和hash来实现？**

hash：O(1)查找，还是无序，排序至少需要O(nlogn)

跳表：查找为O(n)，但是有序



