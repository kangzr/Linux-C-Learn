QUESTION？

**Redis有哪些数据结构？**

**使用过Redis分布式锁么，它是什么回事？**

**假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

**使用过Redis做异步队列么，你是怎么用的？**

**如果有大量的key需要设置同一时间过期，一般需要注意什么？**

**Redis如何做持久化的？**

**Pipeline有什么好处，为什么要用pipeline？**

**Redis的同步机制了解么？**

**是否使用过Redis集群，集群的原理是什么？**



Redis是一个Key-Value存储系统；

Redis将数据存储于内存中，或被配置为使用虚拟内存，这两种方式都可以实现**数据持久化**。

提供基于TCP的协议以及操作丰富的数据结构

定位于一个内存数据库，正因为内存的快速访问特性，才使得Redis能够有如此高的性能，能轻松处理大量复杂数据结构



---

### Redis简介

Redis是一个开源的，使用ANSI C语言编写、遵循BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言API；

具有以下优势：

- 性能极高：Redis纯内存读写，读的速度110,000次/s，写的速度81000次/s
- 丰富的数据类型：Redis支持二进制案例的String、List、Hash、Set及Ordered Set数据类型操作
- 原子：Redis的所有操作都是原子性的，单个操作是原子性，多个操作也支持事务/原子性，通过MULTI和EXEC指令包起来
- 丰富的特性：Redis还支持publish/subscribe、通知、key过期等特性



### Redis基础数据结构

##### 跳跃表skiplist

skiplist是一种有序数据结构，通过在每个节点中维持多个指向其它节点的指针，从而快速访问节点。

支持平均O(logN), 最坏O(N)复杂度的节点查找，还可通过顺序性操作来批量处理节点

在大部分情况下， 跳表的效率可以和平衡树相媲美， 并且因为跳表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳表来代替平衡树。

调表解决的问题是实现对链表的二分查找，牺牲空间换取时间，如果n个元素的链表，需要额外n/2 + n/4 + ... + 2 = n - 2个索引节点。

支持功能

- 插入元素
- 删除元素
- 查找元素
- 查找区间元素
- 输出有序序列

为何redis选择跳表而不是红黑树？

- 红黑树在查找区间元素的效率没有跳表高，其它操作时间复杂度一致
- 相比红黑树，跳表实现比较简单，易读，易维护
- 跳表更加灵活，通过改变索引构建策略，有效平衡效率和内存消耗

zset应用场景

分布式限流

实时排行榜

优先级消息队列



**丰富的编码格式的好处？**

通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。

举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：因为压缩列表比双端链表更节约内存， 并且在元素数量  较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；
但是，随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。

**SDS优势，为什么不直接用C字符串？以及SDS如何扩容**

获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) ，和 C 字符串不同， SDS 在 len 属性中记录了本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)，通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。

设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。

**为什么跳表要用压缩列表指向头指针？**

但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳表进行处理， 比如快速访问跳表的表头节点和表尾节点， 又或者快速地获取跳表节点的数量（也即是跳表的长度）等信息。

**新增数据时，如何确定跳表节点多少层？**

每次创建一个新跳跃表节点时，根据幂次定律（经济学家提出，越大的数出现的概率越小），随机生成一个介于1和32之间的值作为level的数组大小，这个大小就是层高度

**如何在遍历跳表时快速得到当前元素排名？**

遍历过程中所有的跨度(span)之和即为当前rank

**zset何时使用ziplist何时使用skiplist编码？**

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist

- 有序集合保存的元素数量小于128（可配置修改）
- 有序集合保存的所有元素成员的长度都小于64字节

**为什么有序集合需要同时使用跳表和hash来实现？**

hash：O(1)查找，还是无序，排序至少需要O(nlogn)

跳表：查找为O(n)，但是有序



















































