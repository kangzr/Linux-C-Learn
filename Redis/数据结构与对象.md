QUESTION？

**Redis有哪些数据结构？**

**使用过Redis分布式锁么，它是什么回事？**

**假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

**使用过Redis做异步队列么，你是怎么用的？**

**如果有大量的key需要设置同一时间过期，一般需要注意什么？**

**Redis如何做持久化的？**

**Pipeline有什么好处，为什么要用pipeline？**

**Redis的同步机制了解么？**

**是否使用过Redis集群，集群的原理是什么？**



Redis是一个Key-Value存储系统；

Redis将数据存储于内存中，或被配置为使用虚拟内存，这两种方式都可以实现**数据持久化**。

提供基于TCP的协议以及操作丰富的数据结构

定位于一个内存数据库，正因为内存的快速访问特性，才使得Redis能够有如此高的性能，能轻松处理大量复杂数据结构



---





### Redis基础数据结构

5种基础数据结构：string(字符串)，list(链表)，set(集合)，hash(哈希)，zset(有序集合)



#### string(字符串)

并没有直接使用c语言传统的字符串，而是构建了简单动态字符串(simple dynamic string, SDS)的抽象类型；

除了用来保存数据库中的字符串值外，SDS还被用做缓冲区(buffer): AOF模块中的AOF缓冲区以及客户端状态中的输入缓冲区。

```c
// sds.h/sds.c
struct sdshdr {
	int len;	// buf中已占用空间的长度，'\0'不计入
    int free;	// buf中剩余可用空间长度
    char buf;	// 数据空间，以'\0'结尾，便于直接重用C字符串函数库中的函数
};
```

##### SDS与C字符串的区别：

**strlen获取字符串长度**: C字符串时间复杂度为O(N)；SDS记录了字符串长度，时间复杂度为O(1)

**缓冲区溢出**：C需要手动为字符串分配空间，容易产生缓冲区溢出；SDS自动调整空间大小，杜绝溢出。

**SDS内存分配策略**：

缓冲区溢出：字符串拼接时导致（忘记重新增加内存）；

内存泄漏 ：字符串截断操作导致（忘记释放掉不再使用的内存）

针对以上两个问题，SDS提供两种内存分配优化策略如下：

###### SDS空间预分配策略

```c
//sds.c
// 对sds中的buf长度进行扩展， 时间复杂度T=O(N)
sds sdsMakeRoomFor(sds s, size_t addlen) {
    struct sdshdr *sh, *newsh;
    size_t free = sdsavail(s);
    size_t len, newlen;
    // 空间足够，直接返回
    if(free >= addlen) return s;
    // 获取s目前已占用空间长度
    len = sdslen(s);
    sh = (void*) (s-(sizeof(struct sdshdr)));
    // s最少需要长度
    newlen = (len+addlen);
    // 计算所需分配的空间
    // 小于1M，则分配两倍；大于1M, 则多分配1M
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;
    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
    if(newsh == NULL) return NULL;
    newsh->free = newlen - len;
    return newsh->buf;
}
```

###### SDS惰性空间释放策略

删除字符后，不会释放对应的内存。sdstrim



#### list(链表)

```c
// adlist.h/adlist.c
// 双端链表节点
typdef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNOde *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    void (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```



无环链表

常用来做异步队列使用，底层存储为一个quicklist结构；

元素较少时使用一块连续内存存储(ziplist，压缩列表)，将所有元素紧挨着一起存储，分配一块连续内存。

元素较多时会改成quicklist   



#### 字典

使用哈希表作为底层实现

```c
// dict.h/dict.c

```



将一个新的键值对添加到字典里面时，需要根据键值对的键计算出哈希值和索引值，

然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上。





数组+链表二维结构(开链方法解决冲突)；Rehash很耗时，为了高性能，采取渐进式rehash策略。

渐进式rehash：在rehash同时，保留新旧两个hash结构，查询时会同时查询两个hash结构，

然后在后续定时任务中以及hash操作指令中，循序渐进地将旧hash的内容一点点迁移至新的hash结构。搬迁完再取而代之。

最后一个元素移除后，数据结构自动被删除，内存被回收。



##### hashes类型及操作

Redis hash 是一个string类型的field和value的映射表。添加、删除操作都是O(1)。





##### zset(有序集合)

set和map的结合体，一方面是一个set，保证了内部value的唯一性，另一方面可给每个value赋予一个score，代表这个value的排序权重。

内部实现为跳表结构



##### 跳跃表

skiplist是一种有序数据结构，通过在每个节点中维持多个指向其它节点的指针，从而快速访问节点。

支持平均O(logN), 最坏O(N)复杂度的节点查找，还可通过顺序性操作来批量处理节点

调表解决的问题是实现对链表的二分查找，牺牲空间换取时间，如果n个元素的链表，需要额外n/2 + n/4 + ... + 2 = n - 2个索引节点。

支持功能

- 插入元素
- 删除元素
- 查找元素
- 查找区间元素
- 输出有序序列

为何redis选择跳表而不是红黑树？

- 红黑树在查找区间元素的效率没有跳表高，其它操作时间复杂度一致
- 相比红黑树，跳表实现比较简单，易读，易维护
- 跳表更加灵活，通过改变索引构建策略，有效平衡效率和内存消耗

##### 整数集合

##### 压缩列表

为节约内存，由一系列特殊编码的连续内存块组成的顺序型数据结构



